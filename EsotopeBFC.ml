(* Esotope Brainfuck compiler, Ocaml edition
 * Copyright (c) 2009, Kang Seonghoon.
 *)

type memref = int

type 'celltype node =
    | Nop
    | AdjustMemory of memref * 'celltype
    | SetMemory of memref * 'celltype
    | MovePointer of memref
    | Input of memref
    | Output of memref
    | While of memref * 'celltype node list

let parse code =
    let len = String.length code in

    (*
    let rec parse' i acc =
        if i >= len then (len, List.rev acc) else
        match code.[i] with
        | '+' -> parse' (succ i) (AdjustMemory (0, 1) :: acc)
        | '-' -> parse' (succ i) (AdjustMemory (0, -1) :: acc)
        | '>' -> parse' (succ i) (MovePointer 1 :: acc)
        | '<' -> parse' (succ i) (MovePointer ~-1 :: acc)
        | '.' -> parse' (succ i) (Output 0 :: acc)
        | ',' -> parse' (succ i) (Input 0 :: acc)
        | '[' ->
            let newi, nodes = parse' (succ i) [] in
            if newi >= len then failwith "no matching ']'" else
            parse' (succ newi) (While (0, nodes) :: acc)
        | ']' -> (i, List.rev acc)
        | _ -> parse' (succ i) acc
    in
    *)

    let rec accum_memops ht i ptr =
        if i >= len then (len, ptr) else

        let try_find ht k default =
            if Hashtbl.mem ht k then Hashtbl.find ht k else default in

        match code.[i] with
        | '+' ->
            Hashtbl.replace ht ptr (succ (try_find ht ptr 0));
            accum_memops ht (succ i) ptr
        | '-' ->
            Hashtbl.replace ht ptr (pred (try_find ht ptr 0));
            accum_memops ht (succ i) ptr
        | '>' ->
            accum_memops ht (succ i) (succ ptr)
        | '<' ->
            accum_memops ht (succ i) (pred ptr)
        | _ -> (i, ptr)
    in

    let rec parse' i acc =
        if i >= len then (len, List.rev acc) else
        match code.[i] with
        | '+' | '-' | '>' | '<' ->
            let ht = Hashtbl.create 8 in
            let i, ptr = accum_memops ht i 0 in
            let insert_memop k v acc =
                if v == 0 then acc else AdjustMemory (k, v) :: acc in
            let acc = Hashtbl.fold insert_memop ht acc in
            if ptr == 0 then
                parse' i acc
            else
                parse' i (MovePointer ptr :: acc)
        | '.' -> parse' (succ i) (Output 0 :: acc)
        | ',' -> parse' (succ i) (Input 0 :: acc)
        | '[' ->
            let newi, nodes = parse' (succ i) [] in
            if newi >= len then failwith "no matching ']'" else
            parse' (succ newi) (While (0, nodes) :: acc)
        | ']' -> (i, List.rev acc)
        | _ -> parse' (succ i) acc
    in

    let lasti, nodes = parse' 0 [] in
    if lasti < len then failwith "no matching '['" else nodes

let emit_c nodes =
    let rec emit buf indent nodes =
        let rec emit_single_node buf indent node = match node with
            | Nop -> ()
            | AdjustMemory (target, delta) ->
                Printf.bprintf buf "%sp[%d] += %d;\n" indent target delta
            | SetMemory (target, value) ->
                Printf.bprintf buf "%sp[%d] = %d;\n" indent target value
            | MovePointer offset ->
                Printf.bprintf buf "%sp += %d;\n" indent offset
            | Input target ->
                Printf.bprintf buf "%sp[%d] = getchar();\n" indent target
            | Output target ->
                Printf.bprintf buf "%sputchar(p[%d]);\n" indent target
            | While (target, nodes) ->
                Printf.bprintf buf "%swhile (p[%d]) {\n" indent target;
                emit buf (indent ^ "\t") nodes;
                Printf.bprintf buf "%s}\n" indent
        in
        List.iter (emit_single_node buf indent) nodes
    in

    let buf = Buffer.create 1024 in
    Printf.bprintf buf "/* generated by esotope-bfc (ocaml ed.) */\n\
                        #include <stdio.h>\n\
                        #include <stdint.h>\n\
                        uint8_t m[30000], *p = m;\n\
                        int main(void) {\n";
    emit buf "\t" nodes;
    Printf.bprintf buf "}\n";
    Buffer.contents buf

let () =
    let code = "
        >+++++++++[<++++++++>-]<.>+++++++[<++++>-]<+.+++++++..+++.>>>++++++++[<++++>-]
        <.>>>++++++++++[<+++++++++>-]<---.<<<<.+++.------.--------.>>+.
    " in print_string (emit_c (parse code))

