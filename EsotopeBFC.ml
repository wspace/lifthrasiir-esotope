(* Esotope Brainfuck compiler, Ocaml edition
 * Copyright (c) 2009, Kang Seonghoon.
 *)

type memref = int

type 'celltype node =
    | Nop
    | AdjustMemory of memref * 'celltype
    | SetMemory of memref * 'celltype
    | MovePointer of memref
    | Input of memref
    | Output of memref
    | While of memref * 'celltype node list

let parse stream =
    let rec accum_memops ht ptr =
        let try_find ht k default =
            if Hashtbl.mem ht k then Hashtbl.find ht k else default in

        match Stream.peek stream with
        | Some '+' ->
            Hashtbl.replace ht ptr (succ (try_find ht ptr 0));
            Stream.junk stream; accum_memops ht ptr
        | Some '-' ->
            Hashtbl.replace ht ptr (pred (try_find ht ptr 0));
            Stream.junk stream; accum_memops ht ptr
        | Some '>' ->
            Stream.junk stream; accum_memops ht (succ ptr)
        | Some '<' ->
            Stream.junk stream; accum_memops ht (pred ptr)
        | _ -> ptr
    in

    let rec parse' acc =
        match Stream.peek stream with
        | Some ('+'|'-'|'>'|'<') ->
            let ht = Hashtbl.create 8 in
            let ptr = accum_memops ht 0 in
            let insert_memop k v acc =
                if v = 0 then acc else AdjustMemory (k, v) :: acc in
            let acc = Hashtbl.fold insert_memop ht acc in
            if ptr = 0 then
                parse' acc
            else
                parse' (MovePointer ptr :: acc)

        | Some '.' ->
            Stream.junk stream;
            parse' (Output 0 :: acc)

        | Some ',' ->
            Stream.junk stream;
            parse' (Input 0 :: acc)

        | Some '[' ->
            Stream.junk stream;
            let nodes, eof = parse' [] in
            if eof then failwith "no matching ']'" else
            parse' (While (0, nodes) :: acc)

        | Some ']' ->
            Stream.junk stream;
            (List.rev acc, false)

        | Some _ ->
            Stream.junk stream;
            parse' acc

        | None ->
            (List.rev acc, true)
    in

    let nodes, eof = parse' [] in
    if not eof then failwith "no matching '['" else nodes

let emit_c nodes =
    let rec emit buf indent nodes =
        let rec emit_single_node buf indent node = match node with
            | Nop -> ()
            | AdjustMemory (target, delta) ->
                Printf.bprintf buf "%sp[%d] += %d;\n" indent target delta
            | SetMemory (target, value) ->
                Printf.bprintf buf "%sp[%d] = %d;\n" indent target value
            | MovePointer offset ->
                Printf.bprintf buf "%sp += %d;\n" indent offset
            | Input target ->
                Printf.bprintf buf "%sp[%d] = getchar();\n" indent target
            | Output target ->
                Printf.bprintf buf "%sputchar(p[%d]);\n" indent target
            | While (target, nodes) ->
                Printf.bprintf buf "%swhile (p[%d]) {\n" indent target;
                emit buf (indent ^ "\t") nodes;
                Printf.bprintf buf "%s}\n" indent
        in
        List.iter (emit_single_node buf indent) nodes
    in

    let buf = Buffer.create 1024 in
    Printf.bprintf buf "/* generated by esotope-bfc (ocaml ed.) */\n\
                        #include <stdio.h>\n\
                        #include <stdint.h>\n\
                        uint8_t m[30000], *p = m;\n\
                        int main(void) {\n";
    emit buf "\t" nodes;
    Printf.bprintf buf "\treturn 0;\n\
                        }\n";
    buf

let usage () =
    let progname = Sys.executable_name in
    Printf.printf "Esotope Brainfuck compiler (Ocaml edition)\n\
                   Copyright (c) 2009, Kang Seonghoon.\n\n\
                   Usage: %s filename\n\
                  \       %s - (read from stdin)\n" progname progname;
    exit 1

let main argv =
    if (Array.length argv) < 2 then usage () else
    let channel = if argv.(1) = "-" then stdin else open_in argv.(1) in
    let nodes = parse (Stream.of_channel channel) in
    Buffer.output_buffer stdout (emit_c nodes)

let _ = main Sys.argv

